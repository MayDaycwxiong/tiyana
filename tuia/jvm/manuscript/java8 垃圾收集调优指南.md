https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/

# **Java 平台标准版 HotSpot 虚拟机垃圾收集调优指南**

## 2人体工学

![image-20210708224850559](/Users/cuiwx/Library/Application Support/typora-user-images/image-20210708224850559.png)

### 基于行为的调优

##### 最大暂停时间目标

最大暂停时间目标是使用命令行选项指定的`-XX:MaxGCPauseMillis=``<nnn>`。这被解释为对垃圾收集器的提示，即`<nnn>`需要毫秒或更短的暂停时间。垃圾收集器将调整与垃圾收集相关的 Java 堆大小和其他参数，以尝试将垃圾收集暂停短于`<nnn>`毫秒。默认情况下没有最大暂停时间目标。这些调整可能会导致垃圾收集器更频繁地发生，从而降低应用程序的整体吞吐量。

##### 吞吐量目标

吞吐量目标是根据收集垃圾所花费的时间和垃圾收集之外所花费的时间（称为*应用程序时间*）来衡量的。目标由命令行选项指定`-XX:GCTimeRatio=``<nnn>`。垃圾回收时间与应用程序时间之比为 1 / (1 + `<nnn>`)。例如，`-XX:GCTimeRatio=19`将垃圾收集总时间的 1/20 或 5% 设定为目标。垃圾回收所花费的时间是年轻代和老年代回收的总时间。如果未满足吞吐量目标，则增加代的大小以增加应用程序可以在集合之间运行的时间。

## 3 代

当一个对象不能再从正在运行的程序中的任何指针到达时，它就被认为是垃圾。最直接的垃圾收集算法迭代每个可到达的对象。任何剩余的对象都被视为垃圾。这种方法花费的时间与活动对象的数量成正比，这对于维护大量活动数据的大型应用程序来说是令人望而却步的。

虚拟机结合了许多不同的垃圾收集算法，这些算法使用分*代收集*进行组合。虽然原始垃圾收集检查堆中的每个活动对象，但分代收集利用大多数应用程序的几个经验观察属性来最小化回收未使用（垃圾）对象所需的工作。这些观察到的属性中最重要的是弱*世代假设*，它指出大多数对象只能存活很短的时间。

[图 3-1，“对象生命周期的典型分布”中](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/generations.html#distribution_lifetimes)的蓝色区域[是对象生命周期的](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/generations.html#distribution_lifetimes)典型分布。x 轴是以分配的字节数衡量的对象生命周期。y 轴上的字节数是具有相应生命周期的对象中的总字节数。左边的尖峰代表在分配后不久可以回收（换句话说，已经“死亡”）的对象。例如，迭代器对象通常在单个循环的持续时间内处于活动状态。

***图 3-1 对象生命周期的典型分布\***![图 3-1 说明如下](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img/jsgct_dt_003_alc_vs_srvng.png)
[“图 3-1 对象生命周期典型分布”说明](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img_text/jsgct_dt_003_alc_vs_srvng.html)

有些物体确实寿命更长，因此分布向右延伸。例如，通常有一些在初始化时分配的对象会一直存在，直到进程退出。在这两个极端之间是在一些中间计算期间存活的对象，这里被视为初始峰值右侧的块。一些应用程序具有非常不同的外观分布，但令人惊讶的大量应用程序具有这种一般形状。通过关注大多数对象“早逝”这一事实，使高效收集成为可能。

为了针对这种情况进行优化，内存是分*代*管理的（内存池包含不同年龄的对象）。当代填满时，垃圾收集在每一代中发生。绝大多数对象都分配在一个专用于年轻对象（*年轻代*）的池中，并且大多数对象都死在那里。当年轻代填满时，会导致一个*minor collection*其中只收集年轻代；其他世代的垃圾不回收。可以优化次要集合，假设弱代假设成立并且年轻代中的大多数对象都是垃圾并且可以回收。这种收集的成本首先与被收集的活动对象的数量成正比；一个充满死对象的年轻代会很快被收集起来。通常，在每个次要收集期间，年轻代中幸存对象的一部分被移动到年老代。最终，*tenured generation*会填满，必须被收集，导致一个*主要的收集*，其中收集了整个堆。主要集合的持续时间通常比次要集合长得多，因为涉及的对象数量要多得多。

本文档的中心原则：

**笔记：**如果垃圾收集成为瓶颈，您很可能必须自定义总堆大小以及各个代的大小。检查详细垃圾收集器输出，然后探索您的个人性能指标对垃圾收集器参数的敏感性。

在初始化时，最大地址空间实际上是保留的，但除非需要，否则不会分配给物理内存。为对象内存保留的完整地址空间可以分为年轻代和年老代。

年轻代由伊甸园和两个幸存者空间组成。大多数对象最初是在 eden 中分配的。一个幸存者空间在任何时候都是空的，作为 eden 中任何存活对象的目的地；另一个幸存者空间是下一次复制集合期间的目的地。对象以这种方式在幸存者空间之间复制，直到它们足够老到可以被使用（复制到老年代）。

通常，为特定世代选择大小是这些考虑因素之间的权衡。例如，一个非常大的年轻代可能会最大限度地提高吞吐量，但这样做的代价是占用空间、及时性和暂停时间。可以通过以牺牲吞吐量为代价使用小的年轻代来最小化年轻代的暂停。一代的大小不会影响另一代的收集频率和暂停时间。

### 测量

命令行选项`-verbose:gc`导致在每次收集时打印有关堆和垃圾收集的信息。例如，这是一个大型服务器应用程序的输出：`[GC 325407K->83000K(776768K), 0.2300771 秒]  [GC 325816K->83372K(776768K), 0.2454258 秒]  [完整 GC 26767679s ]- >84K7779s,83372K(776768K),84K9769999 `输出显示两个次要集合，后跟一个主要集合。箭头前后的数字（例如，`325407K->83000K`从第一行开始）分别表示垃圾收集前后活动对象的组合大小。小收集后，大小包括一些垃圾（不再活着）但无法回收的对象。这些对象要么包含在老年代，要么被老年代引用。括号中的下一个数字（例如，`(776768K)`再次从第一行开始）是堆的提交大小：Java 对象可使用的空间量，而无需从操作系统请求更多内存。请注意，此数字仅包括一个幸存者空间。除了在垃圾收集期间，在任何给定时间只会使用一个幸存者空间来存储对象。

命令行选项`-XX:+PrintGCDetails`会导致打印有关集合的附加信息。`-XX:+PrintGCDetails`此处显示了使用串行垃圾收集器的输出示例。`[GC [DefNew: 64575K->959K(64576K), 0.0457646 秒] 196016K->133633K(261184K), 0.0459067 秒] `这表明，minor collection 恢复了约 98% 的年轻代，`DefNew: 64575K->959K(64576K)`并且耗时`0.0457646 secs`（约 45 毫秒）。整个堆的使用率降低到大约 51% ( `196016K->133633K(261184K)`)，并且收集有一些轻微的额外开销（超过年轻代的收集），如 的最终时间所示`0.0459067 secs`。

该选项`-XX:+PrintGCTimeStamps`在每个集合的开始添加时间戳。这对于查看垃圾收集发生的频率很有用。`111.042：[GC 111.042：[DefNew：8128K-> 8128K（8128K），0.0000505秒] 111.042：[终身：18154K-> 2311K（24576K），0.1290354秒] 26282K-> 2311K（32704K），0.1293306秒] `收集在应用程序执行后大约 111 秒开始。次要收藏大约在同一时间开始。此外，还显示了 Tenured 描述的主要集合的信息。年老代的使用量减少到大约 10% ( `18154K->2311K(24576K)`) 并花费了`0.1290354 secs`（大约 130 毫秒）。

## 4 Sizing the Generations

许多参数会影响生成大小。[图 4-1，“堆参数”](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html#heap_parameters)说明了堆中已提交空间和虚拟空间之间的区别。在虚拟机初始化时，堆的整个空间都被保留。保留空间的大小可以用`-Xmx`选项指定。如果该`-Xms`参数的值小于该参数的值，则`-Xmx`并非所有保留的空间都会立即提交给虚拟机。未提交的空间在此图中标记为“虚拟”。堆的不同部分（老年代和年轻代）可以根据需要增长到虚拟空间的极限。

一些参数是堆的一部分与另一部分的比率。例如，该参数`NewRatio`表示年老代与年轻代的相对大小。

***图 4-1 堆参数\***![图 4-1 说明如下](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img/jsgct_dt_006_prm_gn_sz.png)
[“图4-1堆参数”说明](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img_text/jsgct_dt_006_prm_gn_sz.html)

### 总堆

以下关于堆的增长和收缩以及默认堆大小的讨论不适用于并行收集器。（见节[并行收集人体工程学](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html#parallel_collector_ergonomics)在[上浆的世代](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html#sizing_generations)对堆调整大小和缺省堆大小与并行收集的信息。）然而，控制堆的总大小和世代的尺寸的参数确实适用于并行收集.

影响垃圾收集性能的最重要因素是总可用内存。因为收集在代填满时发生，所以吞吐量与可用内存量成反比。

默认情况下，虚拟机会在每个集合处增大或缩小堆，以尝试将每个集合处的可用空间与活动对象的比例保持在特定范围内。此目标范围由参数`-XX:MinHeapFreeRatio=``<minimum>`和设置为百分比`-XX:MaxHeapFreeRatio=``<maximum>`，总大小由`-Xms``<min>`和 上下限定`-Xmx``<max>`。64 位 Solaris 操作系统（SPARC 平台版）的[默认参数](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html#default_param_solaris)如[表 4-1“64 位 Solaris 操作系统的默认参数”所示](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html#default_param_solaris)：

表 4-1 64 位 Solaris 操作系统的默认参数范围默认值`MinHeapFreeRatio``40``MaxHeapFreeRatio``70``-Xms``6656k``-Xmx``calculated`



使用这些参数，如果一个代中的可用空间百分比低于 40%，那么该代将被扩展以保持 40% 的可用空间，直到该代的最大允许大小。同样，如果空闲空间超过 70%，那么代将被收缩，只有 70% 的空间是空闲的，受限于代的最小大小。

如[表 4-1，“64 位 Solaris 操作系统的默认参数”](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html#default_param_solaris)中所述，默认的最大堆大小是由 JVM 计算的值。Java SE 中用于并行收集器和服务器 JVM 的计算现在用于所有垃圾收集器。部分计算是最大堆大小的上限，对于 32 位平台和 64 位平台是不同的。请参阅[并行收集器](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html#CHDCFBIF)中[的](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html#CHDCFBIF)[默认堆大小](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html#default_heap_size)部分。客户端 JVM 也有类似的计算，这会导致最大堆大小小于服务器 JVM。

以下是有关服务器应用程序堆大小的一般准则：

- 除非您遇到暂停问题，否则请尝试为虚拟机授予尽可能多的内存。默认大小通常太小。
- 将`-Xms`和设置`-Xmx`为相同的值可通过从虚拟机中删除最重要的大小决定来提高可预测性。但是，如果您做出了错误的选择，虚拟机将无法进行补偿。
- 通常，随着处理器数量的增加而增加内存，因为分配可以并行化。

年轻一代在总可用内存之后，影响垃圾收集性能的第二大因素是专用于年轻代的堆的比例。年轻代越大，小回收发生的频率就越低。然而，对于有界堆大小，较大的年轻代意味着较小的年老代，这将增加主要收集的频率。最佳选择取决于应用程序分配的对象的生命周期分布。默认情况下，年轻代大小由参数控制`NewRatio`。例如，设置`-XX:NewRatio=3`意味着年轻代和年老代的比例为 1:3。换句话说，伊甸园和幸存者空间的总大小将是总堆大小的四分之一。参数`NewSize`和`MaxNewSize`从下到上限制了年轻代的大小。将这些设置为相同的值会修复年轻代，就像设置`-Xms`和设置`-Xmx`为相同的值会修复总堆大小一样。这对于以比 允许的整数倍更细的粒度调整年轻代很有用`NewRatio`。

幸存者空间大小您可以使用`SurvivorRatio`可用于调整幸存者空间大小的参数，但这对于性能而言通常并不重要。例如，`-XX:SurvivorRatio=6`将 eden 和 Survivor 空间之间的比率设置为 1:6。换句话说，每个幸存者空间将是伊甸园大小的六分之一，因此是年轻代大小的八分之一（不是七分之一，因为有两个幸存者空间）。如果幸存者空间太小，复制集合会直接溢出到年老代。如果幸存者空间太大，它们将是无用的空。在每次垃圾回收时，虚拟机都会选择一个阈值数，即对象在使用前可以复制的次数。选择这个阈值是为了让幸存者保持半满。命令行选项`-XX:+PrintTenuringDistribution`（并非在所有垃圾收集器上都可用）可用于显示此阈值和新一代对象的年龄。它对于观察应用程序的生命周期分布也很有用。

[表 4-2，“Survivor Space Sizing 的默认参数值”](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html#defaults_survivor_space)提供了 64 位 Solaris 的默认值：

表 4-2 Survivor Space Sizing 的默认参数值范围服务器JVM默认值`NewRatio``2``NewSize``1310M``MaxNewSize`不限`SurvivorRatio``8`

年轻代的最大大小将由总堆的最大大小和`NewRatio`参数的值来计算。参数的“不受限制”默认值`MaxNewSize`意味着计算值不受限制，`MaxNewSize`除非`MaxNewSize`在命令行上指定了值。

以下是服务器应用程序的一般准则：首先确定您可以为虚拟机提供的最大堆大小。然后根据年轻代大小绘制您的性能指标以找到最佳设置。请注意，最大堆大小应始终小于机器上安装的内存量，以避免过多的页面错误和抖动。如果总堆大小是固定的，那么增加年轻代大小需要减少老年代大小。保持年老代足够大，以容纳应用程序在任何给定时间使用的所有实时数据，以及一定量的空闲空间（10% 到 20% 或更多）。受制于之前对老年代的约束：给予年轻一代足够的记忆。随着处理器数量的增加，增加年轻代的大小，因为分配可以并行化。

## 5 个可用的收集器

到目前为止的讨论都是关于串行收集器的。Java HotSpot VM 包括三种不同类型的收集器，每种收集器具有不同的性能特征。

- 串行收集器使用单个线程来执行所有垃圾收集工作，这使得它相对高效，因为线程之间没有通信开销。它最适合单处理器机器，因为它不能利用多处理器硬件，尽管它对于具有小数据集（最多约 100 MB）的应用程序在多处理器上很有用。在某些硬件和操作系统配置上默认选择串行收集器，或者可以使用选项显式启用`-XX:+UseSerialGC`。

- 并行收集器（也称为*吞吐量收集器*）并行执行次要收集，这可以显着减少垃圾收集开销。它适用于在多处理器或多线程硬件上运行的具有中型到大型数据集的应用程序。并行收集器在某些硬件和操作系统配置上默认选择，或者可以使用选项显式启用`-XX:+UseParallelGC`。

  - 并行压缩是一个特性，它使并行收集器能够并行执行主要收集。如果没有并行压缩，主要收集是使用单个线程执行的，这会显着限制可伸缩性。如果`-XX:+UseParallelGC`已指定该选项，则默认情况下启用并行压缩。关闭它的选项是`-XX:-UseParallelOldGC`。

- 大多数并发收集器同时执行其大部分工作（例如，当应用程序仍在运行时）以保持垃圾收集暂停较短。它专为具有中型到大型数据集的应用程序而设计，其中响应时间比总吞吐量更重要，因为用于最小化暂停的技术会降低应用程序性能。Java HotSpot VM 提供了两个主要并发收集器之间的选择；请参阅[大多数并发收集器](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/concurrent.html#mostly_concurrent)。使用该选项`-XX:+UseConcMarkSweepGC`启用 CMS 收集器或`-XX:+UseG1GC`启用 G1 收集器。

  ### 选择收集器

  除非您的应用程序对暂停时间有相当严格的要求，否则首先运行您的应用程序并允许 VM 选择一个收集器。如有必要，调整堆大小以提高性能。如果性能仍不能满足您的目标，请使用以下指南作为选择收集器的起点。

  如果应用程序的数据集很小（最多大约 100 MB），则选择带有选项的串行收集器`-XX:+UseSerialGC`。

  如果应用程序将在单个处理器上运行并且没有暂停时间要求，那么让 VM 选择收集器，或者选择带有选项的串行收集器`-XX:+UseSerialGC`。

  如果 (a) 峰值应用程序性能是第一优先级并且 (b) 没有暂停时间要求或 1 秒或更长的暂停是可以接受的，那么让 VM 选择收集器，或者选择并行收集器`-XX:+UseParallelGC`。

  如果响应时间比总吞吐量更重要并且垃圾收集暂停必须保持短于大约 1 秒，则使用`-XX:+UseConcMarkSweepGC`或选择并发收集器`-XX:+UseG1GC`。

  ## 6 并行收集器

  并行收集器（这里也称为*吞吐量收集器*）是类似于串行收集器的分代收集器；主要区别在于使用多个线程来加速垃圾收集。并行收集器通过命令行选项启用`-XX:+UseParallelGC`。默认情况下，使用此选项，次要和主要收集并行执行以进一步减少垃圾收集开销。

在*N*大于 8 的具有*N 个*硬件线程的机器上，并行收集器使用*N*的固定分数作为垃圾收集器线程的数量。对于较大的*N*值，该分数约为 5/8 。在*N*值低于 8 时，使用的数字是*N*. 在选定的平台上，这一比例下降到 5/16。垃圾收集器线程的具体数量可以通过命令行选项（稍后介绍）进行调整。在具有一个处理器的主机上，由于并行执行（例如同步）所需的开销，并行收集器的性能可能不如串行收集器。但是，当运行具有中型到大型堆的应用程序时，它通常在具有两个处理器的机器上略胜于串行收集器，并且在有两个以上处理器可用时通常比串行收集器性能要好得多。

可以使用命令行选项控制垃圾收集器线程的数量 `-XX:ParallelGCThreads=``<N>`. 如果使用命令行选项对堆进行显式调整，则并行收集器获得良好性能所需的堆大小与串行收集器所需的堆大小相同。但是，启用并行收集器应该会使收集暂停更短。由于多个垃圾收集器线程参与次要收集，因此在收集期间从年轻代升级到年老代可能会导致一些碎片。次要收集中涉及的每个垃圾收集线程都会保留一部分老年代用于提升，将可用空间划分为这些“提升缓冲区”会导致碎片效应。

**最大垃圾收集暂停时间**：最大暂停时间目标由命令行选项指定`-XX:MaxGCPauseMillis=``<N>`。这被解释为暗示需要`<N>`毫秒或更短的暂停时间；默认情况下，没有最大暂停时间目标。如果指定了暂停时间目标，则会调整与垃圾收集相关的堆大小和其他参数，以尝试使垃圾收集暂停时间短于指定值。这些调整可能会导致垃圾收集器降低应用程序的整体吞吐量，并且无法始终满足所需的暂停时间目标。

**吞吐量**：吞吐量目标是根据垃圾收集所花费的时间与垃圾收集之外所花费的时间（称为应用程序时间）来衡量的。目标由命令行选项指定`-XX:GCTimeRatio=``<N>`，它将垃圾收集时间与应用程序时间的比率设置为`1 / (1 +` `<N>``)`。例如，`-XX:GCTimeRatio=19`将垃圾收集总时间的 1/20 或 5% 设定为目标。默认值为 99，因此垃圾回收时间的目标为 1%。

**足迹**：最大堆足迹使用选项指定`-Xmx``<N>`。此外，只要满足其他目标，收集器就有一个隐含的目标，即最小化堆的大小。

#### 目标的优先级

这些目标按以下顺序处理：最大暂停时间目标吞吐量目标最小足迹目标首先达到最大暂停时间目标。只有在满足之后才能解决吞吐量目标。同样，只有在实现前两个目标之后，才会考虑足迹目标。

代规模调整收集器保存的平均暂停时间等统计信息在每次收集结束时更新。然后进行确定是否达到目标的测试，并对一代的规模进行任何必要的调整。例外情况是，`System.gc()`在保持统计信息和调整世代大小方面，显式垃圾收集（例如，调用）被忽略。代大小的增长和缩小是通过按代大小的固定百分比递增的方式完成的，以便代向上或向下逐步达到其所需的大小。增长和收缩以不同的速度完成。默认情况下，一代以 20% 的增量增长并以 5% 的增量收缩。增长的百分比由`-XX:YoungGenerationSizeIncrement=``<Y>`年轻代和年老代的命令行选项控制`-XX:TenuredGenerationSizeIncrement=``<T>`。一代缩小的百分比由命令行标志调整`-XX:AdaptiveSizeDecrementScaleFactor=``<D>`。如果增长增量是*X* %，那么收缩的减量是*X* / *D* %。如果收集器决定在启动时增加一代，那么增量中会增加一个补充百分比。这种补充会随着收藏数量的增加而衰减，不会产生长期影响。补充的目的是提高启动性能。收缩的百分比没有补充。如果没有达到最大暂停时间目标，那么一次只缩小一代的大小。如果两代的停顿时间都在目标之上，那么停顿时间较大的代的规模先缩小。如果未满足吞吐量目标，则增加两代的大小。每个都按其各自对总垃圾收集时间的贡献成比例增加。例如，如果年轻代的垃圾回收时间是总回收时间的 25%，如果年轻代的完整增量为 20%，那么年轻代将增加 5%。

默认堆大小

除非在命令行中指定了初始和最大堆大小，否则它们是根据机器上的内存量计算的。

客户端 JVM 默认初始和最大堆大小

默认的最大堆大小是物理内存的一半，最大为 192 兆字节 (MB) 的物理内存大小，否则为物理内存的四分之一，最大为 1 吉字节 (GB) 的物理内存大小。

例如，如果您的计算机有 128 MB 的物理内存，则最大堆大小为 64 MB，大于或等于 1 GB 的物理内存导致最大堆大小为 256 MB。

JVM 不会实际使用最大堆大小，除非您的程序创建了足够多的对象来要求它。在 JVM 初始化期间分配的数量要小得多，称为*初始堆大小*。此数量至少为 8 MB，否则为物理内存的 1/64，最大为 1 GB 的物理内存大小。分配给年轻代的最大空间量是总堆大小的三分之一。

##### 服务器 JVM 默认初始和最大堆大小

默认初始和最大堆大小在服务器 JVM 上的工作方式与在客户端 JVM 上的工作方式类似，只是默认值可以更高。在 32 位 JVM 上，如果有 4 GB 或更多的物理内存，则默认的最大堆大小可以高达 1 GB。在 64 位 JVM 上，如果有 128 GB 或更多的物理内存，则默认的最大堆大小可以高达 32 GB。你总是可以通过直接指定这些值来设置更高或更低的初始和最大堆；请参阅下一节。

指定初始和最大堆大小您可以使用标志`-Xms`（初始堆大小）和`-Xmx`（最大堆大小）指定初始和最大堆大小。如果您知道您的应用程序需要多少堆才能正常工作，您可以将`-Xms`和设置`-Xmx`为相同的值。如果不是，JVM 将首先使用初始堆大小，然后增大 Java 堆，直到找到堆使用和性能之间的平衡。

##### 指定初始和最大堆大小

您可以使用标志`-Xms`（初始堆大小）和`-Xmx`（最大堆大小）指定初始和最大堆大小。如果您知道您的应用程序需要多少堆才能正常工作，您可以将`-Xms`和设置`-Xmx`为相同的值。如果不是，JVM 将首先使用初始堆大小，然后增大 Java 堆，直到找到堆使用和性能之间的平衡。其他参数和选项可能会影响这些默认值。要验证您的默认值，请使用该`-XX:+PrintFlagsFinal`选项并`MaxHeapSize`在输出中查找。例如，在 Linux 或 Solaris 上，您可以运行以下命令：`java -XX:+PrintFlagsFinal <GC 选项> -version | grep 最大堆大小 `

##### GC 时间过长和 OutOfMemoryError

`OutOfMemoryError`如果垃圾收集 (GC) 花费了太多时间，并行收集器会抛出 an ：如果总时间的 98% 以上花费在垃圾收集上，并且回收的堆不到 2%，则`OutOfMemoryError`抛出an 。此功能旨在防止应用程序长时间运行而由于堆太小而进展甚微或没有进展。如有必要，可以通过将选项添加`-XX:-UseGCOverheadLimit`到命令行来禁用此功能。

## 7 主要并发收集器

Java Hotspot VM 在 JDK 8 中有两个主要是并发的收集器：

- [并发标记扫描 (CMS) 收集器](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#concurrent_mark_sweep_cms_collector)：此收集器适用于喜欢较短的垃圾收集暂停并且能够与垃圾收集共享处理器资源的应用程序。
- [垃圾优先垃圾收集器](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#garbage_first_garbage_collection)：这种服务器式收集器适用于具有大内存的多处理器机器。它以高概率满足垃圾收集暂停时间目标，同时实现高吞吐量。

##### 并发开销

大多数并发收集器会用处理器资源（否则应用程序可用）来换取更短的主要收集暂停时间。最明显的开销是在收集的并发部分期间使用一个或多个处理器。在*N 个*处理器系统上，集合的并发部分将使用*K* / *N*个可用处理器，其中 1<= *K* <=ceiling{ *N* /4}。（注意*K*的精确选择和边界可能会发生变化。）除了在并发阶段使用处理器之外，还会产生额外的开销以实现并发。因此，虽然并发收集器的垃圾收集暂停通常要短得多，但应用程序吞吐量也往往比其他收集器略低。

在具有多个处理核心的机器上，处理器在收集的并发部分期间可用于应用程序线程，因此并发垃圾收集器线程不会“暂停”应用程序。这通常会导致更短的暂停，但应用程序可用的处理器资源再次减少，并且应该会出现一些减速，尤其是在应用程序最大限度地使用所有处理内核的情况下。随着*N 的*增加，并发垃圾收集导致的处理器资源减少变小，并发收集带来的收益增加。的部分[并行模故障](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#concurrent_mode_failure)在[并发标记扫描（CMS）集电极](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#concurrent_mark_sweep_cms_collector)讨论了这样的缩放潜在限制。

因为在并发阶段至少有一个处理器用于垃圾收集，所以并发收集器通常不会在单处理器（单核）机器上提供任何好处。但是，有一种单独的模式可用于 CMS（不是 G1），它可以在只有一个或两个处理器的系统上实现低暂停；看到[增量模式](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#CJAGIIEJ)在[并发标记扫描（CMS）收集器](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#concurrent_mark_sweep_cms_collector)的详细信息。此功能在 Java SE 8 中已被弃用，可能会在以后的主要版本中删除。

## 8并发标记扫描 (CMS) 收集器

Concurrent Mark Sweep (CMS) 收集器专为喜欢较短的垃圾收集暂停并且能够在应用程序运行时与垃圾收集器共享处理器资源的应用程序而设计。通常，具有相对较大的长期数据集（大型老年代）并在具有两个或多个处理器的机器上运行的应用程序往往会受益于使用此收集器。但是，对于任何具有低暂停时间要求的应用程序，都应考虑使用此收集器。CMS 收集器通过命令行选项启用`-XX:+UseConcMarkSweepGC`。

与其他可用的收集器类似，CMS 收集器是分代的；因此，次要和主要收集都会发生。CMS 收集器尝试通过使用单独的垃圾收集器线程在应用程序线程的执行的同时跟踪可到达的对象来减少由于主要收集而导致的暂停时间。在每个主要收集周期中，CMS 收集器会在收集开始时暂停所有应用程序线程一小段时间，并在收集中间再次暂停。第二次停顿往往是两次停顿中较长的一次。在两次暂停期间，使用多个线程来执行收集工作。

##### 并发模式失败

CMS 收集器使用一个或多个与应用程序线程同时运行的垃圾收集器线程，目的是在年老代变满之前完成它的收集。如前所述，在正常操作中，CMS 收集器在应用程序线程仍在运行的情况下完成大部分跟踪和清除工作，因此应用程序线程只会看到短暂的暂停。但是，如果 CMS 收集器无法在年老代填满之前完成回收无法访问的对象，或者如果分配不能满足年老代中可用的空闲空间块，则应用程序将暂停并完成收集所有应用程序线程都停止了。无法同时完成收集被称为*并发模式失败*并指示需要调整 CMS 收集器参数。如果并发收集被显式垃圾收集 ( `System.gc()`) 或为诊断工具提供信息所需的垃圾收集中断，则报告并发模式中断。

#### GC 时间过长和 OutOfMemoryError

`OutOfMemoryError`如果垃圾收集花费了太多时间，CMS 收集器会抛出 an ：如果总时间的 98% 以上花费在垃圾收集上，而回收的堆少于 2%，则`OutOfMemoryError`抛出an 。此功能旨在防止应用程序长时间运行而由于堆太小而进展甚微或没有进展。如有必要，可以通过将选项添加`-XX:-UseGCOverheadLimit`到命令行来禁用此功能。该策略与并行收集器中的策略相同，只是执行并发收集所花费的时间不计入 98% 的时间限制。换句话说，只有在应用程序停止时执行的收集才会计入过多的 GC 时间。此类收集通常是由于并发模式失败或显式收集请求（例如，对 的调用`System.gc`）。

#### 漂浮垃圾

CMS 收集器与 Java HotSpot VM 中的所有其他收集器一样，是一个跟踪收集器，它至少标识堆中所有可访问的对象。按照 Richard Jones 和 Rafael D. Lins 在他们的出版物*Garbage Collection: Algorithms for Automated Dynamic Memory 中*的说法，它是一个增量更新收集器。由于应用程序线程和垃圾收集器线程在主要收集期间并发运行，垃圾收集器线程跟踪的对象可能随后在收集过程结束时变得无法访问。这种尚未回收的无法访问的对象称为浮动垃圾。*漂浮垃圾*量取决于并发收集周期的持续时间和应用程序引用更新（也称为*突变）*的频率。此外，由于年轻代和年老代是独立收集的，因此每个都充当另一个根的来源。作为粗略的指导方针，尝试将年老代的大小增加 20% 以解决浮动垃圾的问题。在一个并发收集周期结束时堆中的浮动垃圾在下一个收集周期中被收集。

#### 暂停

CMS 收集器在并发收集周期中两次暂停应用程序。第一个暂停是将可从根直接访问的对象（例如，来自应用程序线程堆栈和寄存器的对象引用、静态对象等）和堆中的其他地方（例如，年轻代）标记为活动对象。第一次暂停称为*初始标记暂停*。第二次暂停出现在并发跟踪阶段结束时，它会在 CMS 收集器完成跟踪该对象后查找由于应用程序线程更新对象中的引用而被并发跟踪遗漏的对象。这第二次暂停被称为*备注暂停*。

#### 并发阶段

可达对象图的并发跟踪发生在初始标记暂停和备注暂停之间。在此并发跟踪阶段，一个或多个并发垃圾收集器线程可能正在使用应用程序本来可以使用的处理器资源。因此，即使应用程序线程没有暂停，计算密集型应用程序在此阶段和其他并发阶段也可能会看到应用程序吞吐量相应下降。在备注暂停后，并发清除阶段收集标识为无法访问的对象。一旦一个收集周期完成，CMS 收集器就会等待，几乎不消耗任何计算资源，直到下一个主要收集周期开始。

## 9 垃圾优先垃圾收集器

如果应用程序具有以下一个或多个特征，那么今天使用 CMS 或并行压缩运行的应用程序将受益于切换到 G1。超过 50% 的 Java 堆被实时数据占用。对象分配率或提升率差异很大。应用程序正在经历不希望的长时间垃圾收集或压缩暂停（超过 0.5 到 1 秒）。G1 计划作为并发标记清除收集器 (CMS) 的长期替代品。将 G1 与 CMS 进行比较揭示了使 G1 成为更好解决方案的差异。一个区别是 G1 是一个压缩收集器。此外，与 CMS 收集器相比，G1 提供了更多可预测的垃圾收集暂停，并允许用户指定所需的暂停目标。与 CMS 一样，G1 专为需要更短 GC 暂停的应用程序而设计。

## 10 垃圾优先垃圾收集器调优

正如在[Garbage-First Garbage Collector 一](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#garbage_first_garbage_collection)节中所描述的，G1 GC 是一个区域化和分代的垃圾收集器，这意味着 Java 对象堆（heap）被划分为许多大小相等的区域。启动时，Java 虚拟机 (JVM) 设置区域大小。区域大小可以从 1 MB 到 32 MB 不等，具体取决于堆大小。目标是不超过 2048 个区域。伊甸园、幸存者和老年代是这些区域的逻辑集合，并不连续。

### 标记周期的阶段

**初始标记阶段**：G1 GC 在此阶段标记根。此阶段搭载在正常 (STW) 年轻垃圾收集上。**根区域扫描阶段**：G1 GC 扫描在初始标记阶段标记的幸存者区域以获取对老年代的引用，并标记引用的对象。此阶段与应用程序（不是 STW）同时运行，并且必须在下一个 STW 年轻垃圾收集开始之前完成。**并发标记阶段**：G1 GC 在整个堆中找到可访问的（活动的）对象。此阶段与应用程序同时发生，并且可以被 STW 年轻垃圾收集中断。**Remark阶段**：这个阶段是STW收集，帮助完成标记周期。G1 GC 耗尽 SATB 缓冲区，跟踪未访问的活动对象，并执行引用处理。**清理阶段**：在这个最后阶段，G1 GC 执行会计和 RSet 清理的 STW 操作。在记账期间，G1 GC 识别完全空闲的区域和混合垃圾收集候选者。清除阶段在重置并将空区域返回到空闲列表时部分并发。

## 11 其他注意事项

### 显式垃圾收集

应用程序与垃圾收集交互的另一种方式是通过调用`System.gc()`. 这可能会在不必要时强制执行主要收集（例如，当次要收集就足够时），因此通常应避免。显式垃圾收集的性能影响可以通过使用标志禁用它们来衡量`-XX:+DisableExplicitGC`，这会导致 VM 忽略对 的调用`System.gc()`。

#### 类元数据

Java 类在 Java Hotspot VM 中具有内部表示，称为类元数据。在 Java Hotspot VM 的先前版本中，类元数据是在所谓的永久代中分配的。在 JDK 8 中，永久代被删除，类元数据在本机内存中分配。默认情况下，可用于类元数据的本机内存量是无限的。使用该选项`MaxMetaspaceSize`设置用于类元数据的本机内存量的上限。

Java Hotspot VM 显式管理用于元数据的空间。从操作系统请求空间，然后分成块。类加载器从其块（块绑定到特定的类加载器）中为元数据分配空间。当为类加载器卸载类时，它的块会被回收以供重用或返回给操作系统。元数据使用由`mmap`而非由分配的空间`malloc`。

如果`UseCompressedOops`打开并`UseCompressedClassesPointers`使用，则本机内存的两个逻辑上不同的区域用于类元数据。`UseCompressedClassPointers`使用 32 位偏移量来表示 64 位进程中的类指针，就像`UseCompressedOops`Java 对象引用一样。为这些压缩的类指针（32 位偏移）分配了一个区域。可以设置区域的大小，`CompressedClassSpaceSize`默认为 1 GB。压缩类指针的空间保留为`mmap`初始化时分配的空间，并根据需要提交。将`MaxMetaspaceSize`适用于犯下压缩类空间之和为其他类的元数据的空间。

当相应的 Java 类被卸载时，类元数据被释放。Java 类作为垃圾收集的结果被卸载，并且可能会引发垃圾收集以卸载类和解除分配类元数据。当为类元数据提交的空间达到某个级别（高水位线）时，就会引发垃圾收集。在垃圾收集之后，可能会根据从类元数据中释放的空间量来提高或降低高水位标记。将提高高水位线，以免过早引发另一次垃圾收集。高水位线最初设置为命令行选项的值`MetaspaceSize`。这是上升或下降基础上，选择`MaxMetaspaceFreeRatio`和`MinMetaspaceFreeRatio`. 如果可用于类元数据的已提交空间占类元数据总已提交空间的百分比大于`MaxMetaspaceFreeRatio`，则高水位线将降低。如果小于`MinMetaspaceFreeRatio`，则将提高高水位线。